package crit

import (
	"context"
	"fmt"
	"log/slog"
	"strings"

	"github.com/InsulaLabs/insi/ai/docukit"
	"github.com/InsulaLabs/insi/ai/kit"

	"github.com/tmc/langchaingo/llms"
)

type Config struct {
	Logger        *slog.Logger
	Task          string
	Llm           llms.Model
	MaxIterations int
	Documents     map[string]string
	Kit           *kit.Kit
}

type Crit struct {
	log           *slog.Logger
	kit           *kit.Kit
	task          string
	llm           llms.Model
	maxIterations int
	inquiry       string

	ctx    context.Context
	cancel context.CancelFunc

	dk *docukit.DocuKit
	k  *kit.Kit

	systemForwardPrompt string
}

func NewCrit(config Config) (*Crit, error) {

	dk := docukit.NewDocuKit()
	config.Kit.WithStopTool()

	for name, content := range config.Documents {
		dk.WithDocument(name, content)
	}

	for _, tool := range dk.GetAllTools() {
		config.Kit.WithTool(tool)
	}

	systemForwardPrompt := config.Kit.GetToolForwardPrompt()

	return &Crit{
		log:                 config.Logger,
		kit:                 config.Kit,
		task:                config.Task,
		llm:                 config.Llm,
		dk:                  dk,
		k:                   config.Kit,
		ctx:                 config.Kit.Ctx(),
		cancel:              func() {}, // Handled by kit
		maxIterations:       config.MaxIterations,
		systemForwardPrompt: systemForwardPrompt,
	}, nil
}

func (f *Crit) Run() (map[string]string, error) {

	docNames := []string{}
	for name := range f.dk.GetAllDocuments() {
		docNames = append(docNames, name)
	}

	initialPrompt := fmt.Sprintf(
		`
		You are an AI assistant that serves as a critic. 
		You have been provided with the following documents: %s

		Please read and review ALL of the documents considering that they were generated by another AI assistant
		to meet the user's request: 
		       "%s"

		Your task is to be critical of the documents and provide feedback on the following:
			- Are the documents meeting the user request?
			- Are the documents coherent and well-written?
			- Is the document content well written in the format required by the type of document it is?
		
		You MUST provide your feedback by creating a new document called "feedback_document"
		that gives a detalied list of instructions for the AI generative assistant to follow
		to refine the document to meet the user request.

		If no feedback is needed, you MUST create a "feedback_document" that says "No feedback needed"
		`,
		strings.Join(docNames, ", "),
		f.task,
	)

	messageHistory := []llms.MessageContent{
		llms.TextParts(llms.ChatMessageTypeSystem, initialPrompt),
		llms.TextParts(llms.ChatMessageTypeHuman, "[BEGIN TASK]"),
	}

	f.log.Info("starting work loop", "max_iterations", f.maxIterations)

	totalRetries := 0
	maxRetriesOnIterations := 2
	for retry := 0; retry < maxRetriesOnIterations; retry++ {

		for i := 0; i < f.maxIterations; i++ {
			if f.kit.Ctx().Err() != nil {
				f.log.Info("work context cancelled, exiting loop.")
				break
			}
			f.log.Info("running completion", "iteration", i+1)
			messageHistory = append(messageHistory, llms.TextParts(llms.ChatMessageTypeHuman, fmt.Sprintf(
				"You are on stage %d of %d. If the task is complete, please use the stop tool.", i+1, f.maxIterations)))
			messageHistory = f.kit.Complete(f.kit.Ctx(), messageHistory, kit.WithForcedToolUse())
		}

		totalRetries++

		docs := f.dk.GetAllDocuments()
		if _, ok := docs["feedback_document"]; ok {
			f.log.Info("feedback document found, exiting loop.")
			break
		}

		messageHistory = append(messageHistory, llms.TextParts(
			llms.ChatMessageTypeHuman,
			`No feedback document found. Your task is to create a feedback document that gives a detailed list of instructions for the AI generative assistant to follow to refine the document to meet the user request`))
		messageHistory = f.kit.Complete(f.kit.Ctx(), messageHistory, kit.WithForcedToolUse())

		f.log.Info("work loop finished.", "total_retries", totalRetries)
	}

	if totalRetries >= maxRetriesOnIterations {
		f.log.Error("max retries reached, exiting loop.")
		return nil, fmt.Errorf("max retries reached")
	}

	return f.dk.GetAllDocuments(), nil
}
